
package vulnerability

import (
	"database/sql"
	"fmt"
	"github.com/thrive-spectrexq/NexDefend/internal/models"
	"github.com/thrive-spectrexq/NexDefend/internal/scanners/openvas"
	"github.com/thrive-spectrexq/NexDefend/internal/scanners/trivy"
)

// Status represents the status of a vulnerability.
type Status string

const (
	// StatusDetected is the status for a detected vulnerability.
	StatusDetected Status = "Detected"
	// StatusAssessed is the status for an assessed vulnerability.
	StatusAssessed Status = "Assessed"
	// StatusResolved is the status for a resolved vulnerability.
	StatusResolved Status = "Resolved"
)

// CreateVulnerabilityRequest represents the request to create a vulnerability.
type CreateVulnerabilityRequest struct {
	Description string `json:"description"`
	Severity    string `json:"severity"`
}

// UpdateVulnerabilityRequest represents the request to update a vulnerability.
type UpdateVulnerabilityRequest struct {
	Status *Status `json:"status"`
}

// DiscoverVulnerability creates a new vulnerability in the database.
func DiscoverVulnerability(db *sql.DB, req CreateVulnerabilityRequest, orgID int) (*models.Vulnerability, error) {
	// In a real implementation, you would create the vulnerability in the database.
	return &models.Vulnerability{
		ID:          1,
		Description: req.Description,
		Severity:    req.Severity,
		Status:      string(StatusDetected),
	}, nil
}

// GetVulnerability fetches a single vulnerability from the database.
func GetVulnerability(db *sql.DB, id int, orgID int) (*models.Vulnerability, error) {
	// In a real implementation, you would fetch the vulnerability from the database.
	return &models.Vulnerability{
		ID:          id,
		Description: "Example vulnerability",
		Severity:    "High",
		Status:      string(StatusDetected),
	}, nil
}

// ListVulnerabilities fetches all vulnerabilities from the database.
func ListVulnerabilities(db *sql.DB, status *Status, orgID int) ([]models.Vulnerability, error) {
	// In a real implementation, you would fetch the vulnerabilities from the database.
	return []models.Vulnerability{
		{
			ID:          1,
			Description: "Example vulnerability",
			Severity:    "High",
			Status:      string(StatusDetected),
		},
	}, nil
}

// UpdateVulnerabilityStatus updates the status of a vulnerability in the database.
func UpdateVulnerabilityStatus(db *sql.DB, id int, status Status, orgID int) (*models.Vulnerability, error) {
	// In a real implementation, you would update the vulnerability in the database.
	return &models.Vulnerability{
		ID:          id,
		Description: "Example vulnerability",
		Severity:    "High",
		Status:      string(status),
	}, nil
}

// Scan performs a vulnerability scan on the target.
func Scan(target string) ([]models.Vulnerability, error) {
	openvasScanner := &openvas.MockScanner{}
	trivyScanner := &trivy.MockScanner{}

	openvasVulnerabilities, err := openvasScanner.Scan(target)
	if err != nil {
		return nil, fmt.Errorf("failed to scan with openvas: %w", err)
	}

	trivyVulnerabilities, err := trivyScanner.Scan(target)
	if err != nil {
		return nil, fmt.Errorf("failed to scan with trivy: %w", err)
	}

	var vulnerabilities []models.Vulnerability
	for _, v := range openvasVulnerabilities {
		vulnerabilities = append(vulnerabilities, models.Vulnerability{
			Description: v.Description,
			Severity:    v.Severity,
			Status:      string(StatusDetected),
		})
	}

	for _, v := range trivyVulnerabilities {
		vulnerabilities = append(vulnerabilities, models.Vulnerability{
			Description: v.Description,
			Severity:    v.Severity,
			Status:      string(StatusDetected),
		})
	}

	return vulnerabilities, nil
}
