package vulnerability

import (
	"database/sql"
	"time"
)

// Severity represents the severity level of a vulnerability
type Severity string

const (
	SeverityLow      Severity = "Low"
	SeverityMedium   Severity = "Medium"
	SeverityHigh     Severity = "High"
	SeverityCritical Severity = "Critical"
)

// Status represents the current state of a vulnerability
type Status string

const (
	StatusDetected Status = "Detected"
	StatusAssessed Status = "Assessed"
	StatusResolved Status = "Resolved"
)

// Vulnerability represents a detected system vulnerability
type Vulnerability struct {
	ID             int            `json:"id"`
	Description    string         `json:"description"`
	Severity       Severity       `json:"severity"`
	Status         Status         `json:"status"`
	HostIP         sql.NullString `json:"host_ip"`
	Port           sql.NullInt32  `json:"port"`
	DiscoveredAt   time.Time      `json:"discovered_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
	OrganizationID int            `json:"organization_id"`
}

// CreateVulnerabilityRequest defines the payload for creating a new vulnerability
type CreateVulnerabilityRequest struct {
	Description string   `json:"description"`
	Severity    Severity `json:"severity"`
	HostIP      *string  `json:"host_ip,omitempty"`
	Port        *int     `json:"port,omitempty"`
}

// UpdateVulnerabilityRequest defines the payload for updating a vulnerability
type UpdateVulnerabilityRequest struct {
	Status *Status `json:"status,omitempty"`
}

// DiscoverVulnerability creates a new vulnerability record in the database.
func DiscoverVulnerability(db *sql.DB, req CreateVulnerabilityRequest, organizationID int) (*Vulnerability, error) {
	var vulnerability Vulnerability
	var hostIP sql.NullString
	var port sql.NullInt32

	if req.HostIP != nil {
		hostIP = sql.NullString{String: *req.HostIP, Valid: true}
	}
	if req.Port != nil {
		port = sql.NullInt32{Int32: int32(*req.Port), Valid: true}
	}

	query := `
        INSERT INTO vulnerabilities (description, severity, status, host_ip, port, organization_id, discovered_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        RETURNING id, description, severity, status, host_ip, port, discovered_at, updated_at, organization_id`

	err := db.QueryRow(
		query,
		req.Description,
		req.Severity,
		StatusDetected,
		hostIP,
		port,
		organizationID,
	).Scan(
		&vulnerability.ID,
		&vulnerability.Description,
		&vulnerability.Severity,
		&vulnerability.Status,
		&vulnerability.HostIP,
		&vulnerability.Port,
		&vulnerability.DiscoveredAt,
		&vulnerability.UpdatedAt,
		&vulnerability.OrganizationID,
	)

	if err != nil {
		return nil, err
	}
	return &vulnerability, nil
}

// GetVulnerability retrieves a vulnerability by its ID
func GetVulnerability(db *sql.DB, id int, organizationID int) (*Vulnerability, error) {
	var vulnerability Vulnerability
	query := `
        SELECT id, description, severity, status, host_ip, port, discovered_at, updated_at, organization_id
        FROM vulnerabilities
        WHERE id = $1 AND organization_id = $2`

	err := db.QueryRow(query, id, organizationID).Scan(
		&vulnerability.ID,
		&vulnerability.Description,
		&vulnerability.Severity,
		&vulnerability.Status,
		&vulnerability.HostIP,
		&vulnerability.Port,
		&vulnerability.DiscoveredAt,
		&vulnerability.UpdatedAt,
		&vulnerability.OrganizationID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	return &vulnerability, nil
}

// UpdateVulnerabilityStatus updates the status of a vulnerability
func UpdateVulnerabilityStatus(db *sql.DB, id int, status Status, organizationID int) (*Vulnerability, error) {
	var vulnerability Vulnerability
	query := `
        UPDATE vulnerabilities
        SET status = $1, updated_at = CURRENT_TIMESTAMP
        WHERE id = $2 AND organization_id = $3
        RETURNING id, description, severity, status, host_ip, port, discovered_at, updated_at, organization_id`

	err := db.QueryRow(query, status, id, organizationID).Scan(
		&vulnerability.ID,
		&vulnerability.Description,
		&vulnerability.Severity,
		&vulnerability.Status,
		&vulnerability.HostIP,
		&vulnerability.Port,
		&vulnerability.DiscoveredAt,
		&vulnerability.UpdatedAt,
		&vulnerability.OrganizationID,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	return &vulnerability, nil
}

// ListVulnerabilities returns all vulnerabilities, optionally filtered by status
func ListVulnerabilities(db *sql.DB, status *Status, organizationID int) ([]Vulnerability, error) {
	var rows *sql.Rows
	var err error

	query := `
        SELECT id, description, severity, status, host_ip, port, discovered_at, updated_at, organization_id
        FROM vulnerabilities WHERE organization_id = $1`

	if status != nil {
		query += " AND status = $2 ORDER BY discovered_at DESC"
		rows, err = db.Query(query, organizationID, *status)
	} else {
		query += " ORDER BY discovered_at DESC"
		rows, err = db.Query(query, organizationID)
	}

	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var vulnerabilities []Vulnerability
	for rows.Next() {
		var vuln Vulnerability
		err := rows.Scan(
			&vuln.ID,
			&vuln.Description,
			&vuln.Severity,
			&vuln.Status,
			&vuln.HostIP,
			&vuln.Port,
			&vuln.DiscoveredAt,
			&vuln.UpdatedAt,
			&vuln.OrganizationID,
		)
		if err != nil {
			return nil, err
		}
		vulnerabilities = append(vulnerabilities, vuln)
	}
	return vulnerabilities, nil
}
