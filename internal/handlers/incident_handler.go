package handlers

import (
	"encoding/json"
	"net/http"
	"strconv"
	"time"

	"github.com/gorilla/mux"
	"github.com/thrive-spectrexq/NexDefend/internal/integrations/thehive"
	"github.com/thrive-spectrexq/NexDefend/internal/models"
	"gorm.io/datatypes"
	"gorm.io/gorm"
)

type IncidentHandler struct {
	DB             *gorm.DB
	TheHive        *thehive.Client
	PythonAPI      string
	AIServiceToken string
}

func NewIncidentHandler(db *gorm.DB, pythonAPI, aiToken string) *IncidentHandler {
	return &IncidentHandler{
		DB:             db,
		TheHive:        thehive.NewClient(),
		PythonAPI:      pythonAPI,
		AIServiceToken: aiToken,
	}
}

// CreateIncident creates a new incident (often called by the AI or Correlation Engine)
func (h *IncidentHandler) CreateIncident(w http.ResponseWriter, r *http.Request) {
	var incident models.Incident
	if err := json.NewDecoder(r.Body).Decode(&incident); err != nil {
		http.Error(w, "Invalid input", http.StatusBadRequest)
		return
	}

	// Default status if not provided, but honor input if given (e.g. from AI)
	if incident.Status == "" {
		incident.Status = "Open"
	}
	incident.CreatedAt = time.Now()
	incident.UpdatedAt = time.Now()

	if err := h.DB.Create(&incident).Error; err != nil {
		http.Error(w, "Failed to create incident", http.StatusInternalServerError)
		return
	}

	// Integration: Trigger TheHive if Critical
	if incident.Severity == "Critical" && h.TheHive != nil {
		go func() {
			// Map severity: Critical -> 4
			_ = h.TheHive.CreateAlert(
				incident.Description,
				"Critical Incident generated by NexDefend",
				4,
				strconv.Itoa(incident.ID),
			)
		}()
	}

	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(incident)
}

// GetIncidents returns a filtered and paginated list of incidents
func (h *IncidentHandler) GetIncidents(w http.ResponseWriter, r *http.Request) {
	var incidents []models.Incident

	query := h.DB.Model(&models.Incident{})

	// Filter by status if provided (e.g., ?status=Open)
	status := r.URL.Query().Get("status")
	if status != "" {
		query = query.Where("status = ?", status)
	}

	// Filter by severity if provided
	severity := r.URL.Query().Get("severity")
	if severity != "" {
		query = query.Where("severity = ?", severity)
	}

	// Pagination
	pageStr := r.URL.Query().Get("page")
	limitStr := r.URL.Query().Get("limit")

	page, _ := strconv.Atoi(pageStr)
	if page < 1 {
		page = 1
	}

	limit, _ := strconv.Atoi(limitStr)
	if limit < 1 || limit > 100 {
		limit = 20
	}

	offset := (page - 1) * limit

	query.Order("created_at desc").Offset(offset).Limit(limit).Find(&incidents)
	json.NewEncoder(w).Encode(incidents)
}

// GetIncident returns full details including audit logs/notes
func (h *IncidentHandler) GetIncident(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id := vars["id"]

	var incident models.Incident
	// Preload any related notes or audit logs if you have them in the model
	if err := h.DB.First(&incident, id).Error; err != nil {
		http.Error(w, "Incident not found", http.StatusNotFound)
		return
	}
	json.NewEncoder(w).Encode(incident)
}

type IncidentNote struct {
	Content   string    `json:"content"`
	Timestamp time.Time `json:"timestamp"`
	Author    string    `json:"author"` // Optional, could be "System" or username
}

// UpdateIncident handles status changes, assigning users, and appending notes
func (h *IncidentHandler) UpdateIncident(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id := vars["id"]

	var updateData struct {
		Status   string `json:"status"`
		Assignee string `json:"assignee"`
		Note     string `json:"note"` // Optional note to append
	}

	if err := json.NewDecoder(r.Body).Decode(&updateData); err != nil {
		http.Error(w, "Invalid input", http.StatusBadRequest)
		return
	}

	var incident models.Incident
	if err := h.DB.First(&incident, id).Error; err != nil {
		http.Error(w, "Incident not found", http.StatusNotFound)
		return
	}

	// Apply updates
	if updateData.Status != "" {
		incident.Status = updateData.Status
	}
	if updateData.Assignee != "" {
		incident.AssignedTo = updateData.Assignee
	}

	// Handle Notes
	if updateData.Note != "" {
		var notes []IncidentNote

		// Unmarshal existing notes if any
		if len(incident.Notes) > 0 {
			// Ignore error here, start fresh if corrupted
			_ = json.Unmarshal(incident.Notes, &notes)
		}

		newNote := IncidentNote{
			Content:   updateData.Note,
			Timestamp: time.Now(),
			Author:    "User", // In a real app, extract from context
		}
		notes = append(notes, newNote)

		notesJSON, err := json.Marshal(notes)
		if err != nil {
			http.Error(w, "Failed to process notes", http.StatusInternalServerError)
			return
		}
		incident.Notes = datatypes.JSON(notesJSON)
	}

	incident.UpdatedAt = time.Now()

	if err := h.DB.Save(&incident).Error; err != nil {
		http.Error(w, "Failed to update incident", http.StatusInternalServerError)
		return
	}

	json.NewEncoder(w).Encode(incident)
}

// AnalyzeIncident triggers an AI analysis of the incident
func (h *IncidentHandler) AnalyzeIncident(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	idStr := vars["id"]

	var incident models.Incident
	if err := h.DB.First(&incident, idStr).Error; err != nil {
		http.Error(w, "Incident not found", http.StatusNotFound)
		return
	}

	// Construct Prompt for AI
	prompt := "Analyze this incident: " + incident.Description + ". Severity: " + incident.Severity + ". Suggest remediation."
	
	// Prepare Request to Python AI
	payload := map[string]interface{}{
		"query": prompt,
		"context": incident, 
	}
	
	jsonData, _ := json.Marshal(payload)
	
	// Make Request
	client := &http.Client{Timeout: 30 * time.Second} // Long timeout for LLM
	req, err := http.NewRequest("POST", h.PythonAPI+"/chat", bytes.NewBuffer(jsonData))
	if err != nil {
		http.Error(w, "Failed to create request", http.StatusInternalServerError)
		return
	}
	
	req.Header.Set("Content-Type", "application/json")
	if h.AIServiceToken != "" {
		req.Header.Set("Authorization", "Bearer "+h.AIServiceToken)
	}
	
	resp, err := client.Do(req)
	if err != nil {
		http.Error(w, "Failed to contact AI service", http.StatusBadGateway)
		return
	}
	defer resp.Body.Close()
	
	// Just proxy the response body back
	w.Header().Set("Content-Type", "application/json")
	io.Copy(w, resp.Body)
}
