package handlers

import (
	"database/sql"
	"encoding/json"
	"log"
	"net/http"
	"strconv"

	"github.com/gorilla/mux"
	"github.com/thrive-spectrexq/NexDefend/internal/vulnerability"
)

func CreateVulnerabilityHandler(db *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		orgID, ok := r.Context().Value(organizationIDKey).(int)
		if !ok {
			http.Error(w, "Organization ID not found", http.StatusInternalServerError)
			return
		}

		var req vulnerability.CreateVulnerabilityRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid request payload", http.StatusBadRequest)
			return
		}

		if req.Description == "" || req.Severity == "" {
			http.Error(w, "Description and severity are required", http.StatusBadRequest)
			return
		}

		newVuln, err := vulnerability.DiscoverVulnerability(db, req, orgID)
		if err != nil {
			log.Printf("Error creating vulnerability: %v", err)
			http.Error(w, "Failed to create vulnerability", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusCreated)
		json.NewEncoder(w).Encode(newVuln)
	}
}

func GetVulnerabilityHandler(db *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		orgID, ok := r.Context().Value(organizationIDKey).(int)
		if !ok {
			http.Error(w, "Organization ID not found", http.StatusInternalServerError)
			return
		}

		vars := mux.Vars(r)
		id, err := strconv.Atoi(vars["id"])
		if err != nil {
			http.Error(w, "Invalid vulnerability ID", http.StatusBadRequest)
			return
		}

		vuln, err := vulnerability.GetVulnerability(db, id, orgID)
		if err != nil {
			log.Printf("Error getting vulnerability: %v", err)
			http.Error(w, "Failed to retrieve vulnerability", http.StatusInternalServerError)
			return
		}
		if vuln == nil {
			http.Error(w, "Vulnerability not found", http.StatusNotFound)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(vuln)
	}
}

func ListVulnerabilitiesHandler(db *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		orgID, ok := r.Context().Value(organizationIDKey).(int)
		if !ok {
			http.Error(w, "Organization ID not found", http.StatusInternalServerError)
			return
		}

		statusQuery := r.URL.Query().Get("status")
		var status *vulnerability.Status

		if statusQuery != "" {
			s := vulnerability.Status(statusQuery)
			status = &s
		}

		vulnerabilities, err := vulnerability.ListVulnerabilities(db, status, orgID)
		if err != nil {
			log.Printf("Error listing vulnerabilities: %v", err)
			http.Error(w, "Failed to retrieve vulnerabilities", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(vulnerabilities)
	}
}

func UpdateVulnerabilityHandler(db *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		orgID, ok := r.Context().Value(organizationIDKey).(int)
		if !ok {
			http.Error(w, "Organization ID not found", http.StatusInternalServerError)
			return
		}

		vars := mux.Vars(r)
		id, err := strconv.Atoi(vars["id"])
		if err != nil {
			http.Error(w, "Invalid vulnerability ID", http.StatusBadRequest)
			return
		}

		var req vulnerability.UpdateVulnerabilityRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid request payload", http.StatusBadRequest)
			return
		}

		if req.Status == nil {
			http.Error(w, "Status is required", http.StatusBadRequest)
			return
		}

		updatedVuln, err := vulnerability.UpdateVulnerabilityStatus(db, id, *req.Status, orgID)
		if err != nil {
			if err == sql.ErrNoRows {
				http.Error(w, "Vulnerability not found", http.StatusNotFound)
				return
			}
			log.Printf("Error updating vulnerability: %v", err)
			http.Error(w, "Failed to update vulnerability", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(updatedVuln)
	}
}
