package vulnerability

import (
	"errors"
	"fmt"
	"log"
	"sync"
	"time"
)

// Severity represents the severity level of a vulnerability
type Severity string

const (
	SeverityLow      Severity = "Low"
	SeverityMedium   Severity = "Medium"
	SeverityHigh     Severity = "High"
	SeverityCritical Severity = "Critical"
)

// Status represents the current state of a vulnerability
type Status string

const (
	StatusDetected Status = "Detected"
	StatusAssessed Status = "Assessed"
	StatusResolved Status = "Resolved"
)

// Vulnerability represents a detected system vulnerability
type Vulnerability struct {
	ID           int       `json:"id"`
	Description  string    `json:"description"`
	Severity     Severity  `json:"severity"`
	Status       Status    `json:"status"`
	DiscoveredAt time.Time `json:"discovered_at"`
	UpdatedAt    time.Time `json:"updated_at"`
}

// VulnerabilityManager manages vulnerabilities and tracks their status
type VulnerabilityManager struct {
	vulnerabilities map[int]*Vulnerability
	mu              sync.Mutex
	nextID          int
}

// NewVulnerabilityManager initializes a new VulnerabilityManager instance
func NewVulnerabilityManager() *VulnerabilityManager {
	return &VulnerabilityManager{
		vulnerabilities: make(map[int]*Vulnerability),
		nextID:          1,
	}
}

// DiscoverVulnerability creates a new vulnerability record in the manager
func (m *VulnerabilityManager) DiscoverVulnerability(description string, severity Severity) (*Vulnerability, error) {
	if description == "" {
		return nil, errors.New("vulnerability description cannot be empty")
	}
	if severity != SeverityLow && severity != SeverityMedium && severity != SeverityHigh && severity != SeverityCritical {
		return nil, errors.New("invalid severity level")
	}

	m.mu.Lock()
	defer m.mu.Unlock()

	vulnerability := &Vulnerability{
		ID:           m.nextID,
		Description:  description,
		Severity:     severity,
		Status:       StatusDetected,
		DiscoveredAt: time.Now(),
		UpdatedAt:    time.Now(),
	}
	m.vulnerabilities[vulnerability.ID] = vulnerability
	m.nextID++

	log.Printf("New vulnerability discovered: %+v", vulnerability)
	return vulnerability, nil
}

// GetVulnerability retrieves a vulnerability by its ID
func (m *VulnerabilityManager) GetVulnerability(id int) (*Vulnerability, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	vulnerability, exists := m.vulnerabilities[id]
	if !exists {
		return nil, fmt.Errorf("vulnerability with ID %d not found", id)
	}
	return vulnerability, nil
}

// AssessVulnerability marks a vulnerability as assessed
func (m *VulnerabilityManager) AssessVulnerability(id int) error {
	return m.updateVulnerabilityStatus(id, StatusAssessed)
}

// ResolveVulnerability marks a vulnerability as resolved
func (m *VulnerabilityManager) ResolveVulnerability(id int) error {
	return m.updateVulnerabilityStatus(id, StatusResolved)
}

// updateVulnerabilityStatus updates the status and timestamp of a vulnerability
func (m *VulnerabilityManager) updateVulnerabilityStatus(id int, status Status) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	vulnerability, exists := m.vulnerabilities[id]
	if !exists {
		return fmt.Errorf("vulnerability with ID %d not found", id)
	}

	vulnerability.Status = status
	vulnerability.UpdatedAt = time.Now()

	log.Printf("Vulnerability status updated: %+v", vulnerability)
	return nil
}

// ListVulnerabilities returns all vulnerabilities, optionally filtered by status
func (m *VulnerabilityManager) ListVulnerabilities(status *Status) []*Vulnerability {
	m.mu.Lock()
	defer m.mu.Unlock()

	var vulnerabilities []*Vulnerability
	for _, vulnerability := range m.vulnerabilities {
		if status == nil || vulnerability.Status == *status {
			vulnerabilities = append(vulnerabilities, vulnerability)
		}
	}
	return vulnerabilities
}
